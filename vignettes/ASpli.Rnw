%\VignetteIndexEntry{Analysis of alternative splicing using ASpli}
%\VignetteKeywords{Alternative splicing analysis}
%\VignettePackage{ASpli}
\documentclass{article}
<<style, echo=FALSE, results=tex>>=
BiocStyle::latex()
options(continue=" ")
@

\usepackage{verbatim} 
\usepackage{caption} 
\usepackage{cite}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{float}

\newcommand{\RNAseq}{\textrm{\textbf{RNA}-\textbf{Seq}}}
\newcommand{\secref}[1]{\ref{#1} : \nameref{#1}}

\newfloat{captionedEq}{thp}{eqc}
\floatname{captionedEq}{Equation}

\title{\texttt{ASpli}: An integrative R package for analysing alternative 
  splicing using RNA-seq}

\author{Estefania Mancini, Andres Rabinovich, Javier Iserte, Marcelo Yanovsky, Ariel Chernomoretz}

\begin{document}

\SweaveOpts{concordance=TRUE}

\maketitle

\tableofcontents

\section{Introduction and quick start}

Alternative splicing (AS) is a common mechanism of post-transcriptional gene 
regulation in eukaryotic organisms that expands the functional and regulatory 
diversity of a single gene by generating multiple mRNA isoforms that encode 
structurally and functionally distinct proteins. The development of novel 
high-throughput sequencing methods for RNA (RNAseq) has provided a powerful 
means of studying AS under multiple conditions and in a genome-wide manner 
\cite{pmid24549677}. However, using RNAseq to study changes in AS under 
different experimental conditions is not trivial. 
In this vignette, we describe how to use ASpli, an integrative and user-friendly
R package that facilitates the analysis of changes in both annotated and novel 
AS events. This package combines statistical information from exon, intron, and 
splice junction differential usage (p-value, FDR), with information from splice 
junction reads to calculate differences in the percentage of exon inclusion 
($\Delta$PSI) and intron retention ($\Delta$PIR). The proposed methodology 
reliably reflect the magnitude of changes in the relative abundance of different 
annotated and novel AS events. This method can be used to analyze both simple 
and complex experimental designs involving multiple experimental conditions.
\section{Getting started}

\subsection{Installation}
ASpli is available at Bioconductor site and can be downloaded using
\texttt{biocLite()}:
<<installation, echo=TRUE, eval=FALSE>>=
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("ASpli")
@
%<<loadASpli, echo=TRUE, eval=TRUE>>=
<<loadASpli, echo=TRUE, eval=FALSE>>=
library(ASpli)
@
 
\texttt{BiocManager()} will install the packages and dependencies 
e.g. edgeR, GenomicFeatures, GenomicRanges, GenomicAlignments, Gviz, 
and other R package required. 
(No es necesario para mi)
Some other packages depend on operating system packages and should be installed by the user. 

\subsection{Required data}

ASpli requires the \texttt{BAM} and \texttt{BAI} files for each sample in the experiment and the gene annotation in the format of TxDb. Please, \texttt{make sure all files use the same coordinate system}.

\subsection*{Building a \texttt{TxDb} of your genome}
Gene annotation is handled using \texttt{TxDb} objects, which are provided by
\texttt{GenomicFeatures} package. 
The building of a \texttt{TxDb} object might be time consuming, depending on the size of your genome.
If a \texttt{TxDb} has been already created, we strongly recommend saving it as a \texttt{sqlite} file
and reloading it any time the analysis is run. The \texttt{GenomicFeatures} 
package provides functions to create TxDb objects based on data downloaded from
UCSC Genome Bioinformatics, BioMart or gff/gtf files. See "Creating New TxDb 
Objects or Packages" in the \texttt{GenomicFeatures} vignette for more details.
In this example, a TxDb is built from a gtf file:

<<makeTx, echo=TRUE, eval=FALSE>>=
library(GenomicFeatures)
TxDb <- makeTxDbFromGFF(
  file="genes.gtf",
  format="gtf")
@

\subsection{Quick start}
This is the simplest case, a pairwise comparison between 2 conditions: Control and treatment, 3 replicates each:
<<quickStart, echo=TRUE, eval=FALSE>>=

genome <- loadDb("txdb.sqlite")
bams <- NULL
features    <- binGenome(genome)
targets <- data.frame(
  bam = c("CT_1.bam", "CT_2.bam","CT_3.bam",
            "TR_1.bam", "TR_2.bam", "TR_3.bam"),
  genotype = c( "CT", "CT", "CT",  "TR", "TR", "TR" ),
  stringsAsFactors = FALSE )
counts      <-  gbCounts(features = features, 
                         bam = bams, 
                         targets = targets, 
                         minReadLength = 125L, 
                         maxISize = 50000)
asd         <-  jCounts(counts = counts, 
                        features = features,
                        bam= bams, 
                        minReadLength =125L)
mBAMs <- data.frame(
  bam=c("CT.bam", "TR.bam"),
  condition=c("CT","TR"))
contrasts  <- list(A_B = c(-1, 1))
gb      <- gbDUreport(counts, contrast = c(-1, 1))
jdur    <- jDUreport(asd, contrast =  c(-1, 1),
                     runUniformityTest = TRUE,
                     mergedBams = mBAMs,
                     strongFilter=TRUE)
sr      <- splicingReport(gb, jdur, counts)
is      <- integrateSignals(sr,asd)
reports <- list(gb=gb,j=jdur,sr=sr,is=is)
@ 


\section{Running \texttt{ASpli}}
The workflow intended to be used with \texttt{ASpli} is divided in four main steps (Figure \ref{fig:ASpliStructure}). For each of these steps ASpli provides a single or few functions to use:
\begin{enumerate}
  \item Extract features from genome TxDb: \texttt{ binGenome() }
  \item Counting:  \texttt{ gbCounts()},  \texttt{ jCounts()}
  \item Differential signals:\texttt{ gbDUreport()}, 
  \texttt{  jDUreport()}
  \item Reports: \texttt{ splicingReport() }, \texttt{ integrateSignals() }
\end{enumerate}

At each step it is possible to export results easily. 
See Section \ref{sec:outputs}:\nameref{sec:outputs} for more details.

ASpli defines XXX four major objects classes used to store data and perform operations:
CHEQUEAR
\begin{description}
  \item[ASpliFeatures] Contains genomic coordinates
  \item[ASpliCounts] Contains number of reads overlapping each genomic feature
  \item[ASpliJCounts] Contains counts of aligned junctions 
  \item[ASpliDU] Contains results of Differential expression and usage
  \item[ASpliJDU] Contains results of Differential Junctions usage
  \end{description}

\begin{figure}[ht!]
\centering
\includegraphics[width=0.85\textwidth]{images/ASpliCoreFunctionality.png}
\caption{ ASpli core Funcionalities }
\label{fig:ASpliStructure}
\end{figure}

\subsection{Splicing event assignation} \label{sec:eventAssign}
\label{sec:binDefinition}
Sub-genic features such as exons and introns are analyzed using the annotation by splitting the genome into non-overlapping features called bins, 
following the methodology proposed for DEXSeq \cite{pmid22722343}. Exon and intron 
coordinates are then extracted from the annotation, but only those from 
multi-exonic genes are saved for further evaluation. When more than one isoform 
exists, some exons and introns will overlap. Exons and introns are then 
subdivided into new features called exon and intron bins, and are then 
classified into {\em exclusively exonic bins}, {\em exclusively intronic bins}, or 
{\em alternative splicing bins} (AS) (See Figure \ref{fig:binDefinition}). 
In addition to these non overlapping bins, an additional type of bin is also
defined. The latter corresponds to full introns extracted from annotation,
before they are splitted by the presence of overlapping exons in another
isoform. These bins as referred as \emph{intron original} bins (Io).

\begin{figure}[ht!]
\centering
\includegraphics[width=12cm]{images/binDefinition.pdf}
\caption{ Schema of resulting bins from a gene with three hypothetical
  transcripts. Those bins that are exonic and intronic in different isoforms are     named \textit{AS bins}.
}
\label{fig:binDefinition}
\end{figure}



Each AS bin is assigned to a kind of splicing event. The assignation is
made using {\em minimum  local gene models} considering unique patterns of three bins: the bin being evaluated and 
the two neighbor bins (one to the left, one to 
the right). Figure (\ref{fig:binAssignation}) shows examples of  splicing event categorization for different 
{\em minimum local gene models}.\\


When the minimum local gene model contains two isoforms (see first row of figure \ref{fig:binAssignation}) bins are labelled as follow:

\begin{itemize}
  \item \textbf {ES} Exon skipping
  \item \textbf {IR} Intron retention
  \item \textbf {ALt5'SS} Alternative 5' splicing site
  \item \textbf {ALt3'SS} Alternative 3' splicing site
\end{itemize}

When the minimum gene model contains three, four or five isoforms (no
more than five non redundant isoforms can exist in the minimum gene model),
labels of bins are similar to the ones defined previously but have an extra '*'
character ( \textbf{IR*}, \textbf{ES*}, \textbf{Alt5'SS*}, 
\textbf{Alt3'SS*}) in order to show that more than two isoforms exists and, 
therefore, the results should be used with caution (see rows 2-4 of figure \ref{fig:binAssignation}). 
This type of splicing events involve intronic subgenic regions sourrounded by exons in at least one isoform (\textbf{IR*}), and 
exonic subgenic regions sourrounded by two introns in at least one isoform (\textbf{ES*}). Minimum local gene models that do not 
fit in those categories are typified as \textbf{Alt5'SS*} or \textbf{Alt3'SS*} if they present exonic regions sourrounded by intronic 
and exonic neighbor subgenic regions.

In some cases, it is not possible to make a clear assignation for a bin with 
assumptions made here, those bins are labelled as \textbf{Undefined AS} (last
row of figure \ref{fig:binAssignation}).

Additionally, those bins that overlap with the beginning or ending of any transcript are labelled as \textbf{external}. Please note that an external bin of a transcript may overlap to a non external bin of another transcript, in these cases the bin is still labelled as \textbf{external}. 


\begin{figure}[ht!]
\centering
\includegraphics[width=0.9\textwidth]{images/event_assignment.pdf}
\caption{ Summary of assignation of splicing events to bins from minimum gene
model. The bin being evaluated has a green background highlight. The blue boxes
represents exons, while the little light orange boxes represent introns. Gene
models shown are plus sense strand. }
\label{fig:binAssignation}
\end{figure}

\subsubsection*{\texttt{binGenome()} method }
\label{sectionBinG}

The \texttt{binGenome} method is a one-stop function to perform:
\begin{itemize}
 \item subgenic splitting of genes into bins
 \item junction, gene and bin coordinates extraction
 \item bin splicing event assignation
\end{itemize}


Subgenic features are named as follow. For an hypothetical gene named GeneAAA:
\begin{itemize}
  \item \textbf{GeneAAA:E001}: defines first exonic bin
  \item \textbf{GeneAAA:I001}: defines first intronic bin
  \item \textbf{GeneAAA:Io001}: defines first \texttt{Intron original} before 
  being divided
  \item \textbf{GeneAAA:J001}: defines first annotated junction of GeneAAA
  \item \textbf{chr.start.end}: defines an experimental junction, \texttt{chr}
  is the chromosome name, \texttt{start} is the leftmost position of
  the junction and \texttt{end} is the rightmost position of the junction.   
\end{itemize}

Bins and junctions are consecutively named from 5' to 3' sense of the plus
strand of the reference sequence. This implies that  bins and junctions with
lower numbering are always closer to the 5' of that strand. Alternative splicing
bins are named as exons.


\texttt{binGenome}'s output is an object of class \texttt{ASpliFeatures}.

Methods \texttt{featuresg}, \texttt{featuresb}, \texttt{featuresj} can be used to
access genes, bins and junctions coordinates as \texttt{GRanges-List} (for the first case)
or as \texttt{GRanges} objects (for bins and junctions).
\texttt{GRangesList} and \texttt{GRanges} are objects defined in the \texttt{GenomicRanges} package. These objects contains
aditional information stored as metadata that can be accessed with \texttt{mcols} function.

<<binGenome, echo=TRUE, eval=FALSE>>=
annFile       <- aspliExampleGTF()
aTxDb         <- makeTxDbFromGFF(annFile)
features      <- binGenome( aTxDb ) 
annFile       <- aspliExampleGTF()
aTxDb         <- makeTxDbFromGFF(annFile)
features      <- binGenome( aTxDb ) 
geneCoord     <- featuresg( features )
binCoord      <- featuresb( features )
junctionCoord <- featuresj( features )
binMetadata   <- mcols( binCoord )
@

<<binGenome, echo=TRUE, eval=FALSE>>=
symbols       <- data.frame( row.names = genes( aTxDb ), 
                             symbol = paste( 'This is symbol of gene:',
                                             genes( aTxDb ) ) )
features      <- binGenome( aTxDb, geneSymbols = symbols ) 
@

\subsubsection{Target definition}
\label{sec:targetsDef}
Sample names, genomic alignment file names and experimental factors should be specified in a \texttt{data.frame} that has as many rows as samples. Each row should be named with the corresponding sample name. The first column must be named \texttt{bam} and should contain the path to a bam file. The remaining columns should be used to state the corresponding experimental factors for each sample. This \texttt{data.frame} is referred to as the \textbf{targets} \texttt{data.frame}. 
For example, for a one factor experiment with two conditions (Control and Mutant) and two replicates for each condition, the \textbf{targets} \texttt{data.frame} could be defined as follow:

<<targetsDF, echo=TRUE, eval=TRUE>>=
bamFiles = c("CT_1.bam", "CT_2.bam","CT_3.bam",
            "TR_1.bam", "TR_2.bam", "TR_3.bam")
targets <- data.frame(
  bam = c("CT_1.bam", "CT_2.bam","CT_3.bam",
            "TR_1.bam", "TR_2.bam", "TR_3.bam"),
  genotype = c( "CT", "CT", "CT",  "TR", "TR", "TR" ),
  stringsAsFactors = FALSE )
@ 

More sofisticated designs should be specified as follow. For example: for a two factor experiment (factors genotype and time), with two values for each factor adn two replicates for each condition, the \textbf{targets} \texttt{data.frame} can be defined as follow:
<<targetsDF2, echo=TRUE, eval=TRUE>>=
bamFiles <- c("CT_time1_rep1.bam", "CT_time1_rep2.bam",
              "CT_time2_rep1.bam", "CT_time2_rep2.bam",
              "TR_time1_rep1.bam", "TR_time1_rep2.bam",
              "TR_time2_rep1.bam", "TR_time2_rep2.bam")
targets_2 <- data.frame( row.names = c( 'CT_t1_r1',  'CT_t1_r2',
                                        'CT_t2_r1',  'CT_t2_r2',
                                        'TR_t1_r1', 'TR_t1_r2',
                                        'TR_t2_r1', 'TR_t2_r2' ),
                         bam = bamFiles,
                         genotype = c( 'CT', 'CT', 'CT',  'CT', 
                                       'TR', 'TR', 'TR', 'TR' ),
                         time     = c( 't1', 't1', 't2', 't2', 
                                       't1', 't1', 't2', 't2' ),
                         stringsAsFactors = FALSE )
@

The name of the each experimental condition is determined from the experimental factors defined in the \textbf{targets} \texttt{data.frame}. They can be consulted using the \texttt{getConditions} function. 

<<targetsDF2, echo=TRUE, eval=FALSE>>=
getConditions( targets_2 )
@

\subsection{Read counting} 
\label{sec:rcounts}
\subsubsection{Summarize read overlaps against all feature levels}

The method  \texttt{gbCounts()} allow to count the number of reads that overlaps each feature of interest (i.e. genes, bins, junctions, and intron/exon flanking regions). For genes and bins, read density values are also calculated considering the ratio between the number of overlapping reads and the length of a given feature. The following parameters should be specify:

<<gbCounts, echo=TRUE, eval=FALSE>>=
counts      <-  gbCounts(features, 
                         bam, 
                         targets, 
                         minReadLength,
                         maxISize,
                         cores)
@

\begin{itemize}
\item \texttt{features}: An object of class \texttt{ASpliFeatures}. It is a list of GRanges at gene, bin and junction level
\item \texttt{bam}: List of GAlignments objects corresponding to bam files of samples. If NULL is passed (default), bam files are read and processed sequentially. This is usually preferred if machine has low resources.
\item \texttt{targets}: A dataframe containing sample, bam and experimental factors columns, as defined in section \secref{sec:targetsDef}. 
\item \texttt{minReadLength}: Minimum read length of sequenced library. It is used for computing E1I and IE2 read summarization. Make sure this number is smaller than the maximum read length in every bam file, otherwise no E1I or IE2 will be found.
\item \texttt{maxISize}: Maximum intron expected size. Junctions longer than this size will be dicarded  \cite{Hong01122006}.
\item \texttt{cores}: Number of cores to use (Default=1). If bam = NULL, only 1 core is used independently of this parameter.
\item \texttt{minAnchor}: Minimum percentage of read that should be aligned to an exon-intron boundary (see \secref{sec:intronFlanking} ). 
\end{itemize}

The result of \texttt{gbCounts} method is an object of class 
\texttt{ASpliCounts}. Count and read density data could be extracted from it as \texttt{data.frame} objects using accesors methods. Also, it is possible to export count and read densities tables to text files in a tidy manner. \\

Accessing count and read density data:
<<readCountAccessors, echo=TRUE, eval=FALSE>>=
GeneCounts <- countsg(counts)
GeneRd <- rdsg(counts)
BinCounts <- countsb(counts)
BinRd <- rdsb(counts)
JunctionCounts <- countsj(counts)
@
Export count data to text files 

<<readCountWrite, echo=TRUE, eval=FALSE>>=
writeCounts(counts=counts, output.dir = "example")
writeRds(counts=counts, output.dir = "example")
@

\subsubsection*{Additional considerations}
\label{sec:intronFlanking}
\begin{itemize}
\item Every intron is considered as a potential retained intron. 
To analyze putative retention events for intron I, \texttt{ASpli} considers the  corresponding adjacent 5' and 3' exons (E1 and E2, following the order in the genomic coordinates, regardless of the sense of the strand). Then, following \cite{pmid25258385}, new artificial ranges that overlap the two retention regions E1I 
(connecting exon E1 and intron I) and IE2 (connecting intron I and exon E2) are defined:

\begin{itemize}
  \item E1I: intron start - (readLength - minAnchor) --- intron start + (  readLength - minAnchor )
  \item IE2: intron end - (readLength - minAnchor) --- intron end + ( readLength - minAnchor )
  \item \texttt{ minAnchor } is 10\% of read length by default (parameter \texttt{minAnchor} )
\end{itemize}
\textbf{Please check before start the read length of your sequenced library}
Only those reads which minimum overlap \textit{readLength} and without gap in this interval are considered. Accordingly, only sequences aligned within those two exons/introns are counted. If the reads of your genomic alignment are trimmed by quality rendering reads with a length inferior to the nominal
read length, then \texttt{E1I} and \texttt{IE2} values will be underestimated.\\
Accessing counts for intron flanking regions:
<<readCountAccessors2, echo=TRUE, eval=FALSE>>=
e1iCounts <- countse1i(counts)
ie2Counts <- countsie2(counts)
@

\item For a given gene, the count number is computed as
the number of reads overlapping any exon included in the corresponding annotated gene model. If a single read overlaps more than one exon, it is counted only once. Note that \textbf{one read can
overlap two different genes, in this case it is counted for both of them}.
 
\item Effective length: is calculated as the sum of the length of exonic bins and alternative bins (i.e. all bins except intronic bins).

\item Junctions are extracted from BAM files. They are defined as those reads
that aligned against disjoint region of the reference genome(N operator of CIGAR notation
for aligned reads \cite{pmid19505943} ), and are essential piece of information for alternative
splicing event quantification and discovery. Junction alignment
quality/confidence is extremely important and it should be controlled at the moment of the alignment step.
\end{itemize}

\subsubsection{The ASpliCounts object }
\label{sec:countsContents}

Gene an bin information stored in an \texttt{binCounts} object can 
be accessed  as stated in section (\ref{sec:rcounts}) and (\ref{sec:intronFlanking}).
Accesor functions returns \texttt{data.frame} objects with the required information. They typically share the same general structure, but also include specific content depending on the
nature of the requested feature.  See (\ref{sec:outputs}) section for more detailed overview.

\subsubsection{Report PSI, PJU and PIR using experimental junctions}
Summarize read overlaps against junctions. Report PSI, PJU, PIR and counts for experimental junctions. PSI or PIR metrics are calculated for each bin and experimental condition. The selection of which metric is used is based on the kind of splicing event associated with each bin.

<<asd, echo=TRUE, eval=FALSE>>=
asd         <-  jCounts(counts, 
                        features,
                        bam, 
                        minReadLength,
                        threshold,
                        cores,
                        minAnchor)
@
Exclusive parameters:
\begin{itemize}
\item counts: An object of class \texttt{ASpliCounts}
\item threshold: Minimum number of reads supporting junctions (Default=5)
\end{itemize}

Results: An object of class \texttt{ASpliAS}.
The contents of an \texttt{ASpliAS} object can be retrieved using accessor methods: \texttt{irPIR}, \texttt{altPSI}, \texttt{esPSI},
\texttt{joint} \texttt{\mbox{junctionPIR}}, \texttt{\mbox{junctionPSI}} (see
section \secref{secASpliAsContent} for a detailed description of each method and 
retrieved data). 
In addition, method \texttt{writeAS}, allows to easily export 
all the data into text files tables. See (\ref{sec:outputs}) for details

<<asdAccesor, echo=TRUE, eval=FALSE>>=
irPIR  <- irPIR( asd )
altPSI <- altPSI( asd )
esPSI  <- esPSI( asd )
junctionsPIR <- junctionsPIR( asd )
allBins      <- joint( asd )
@

<<asdAccesor, echo=TRUE, eval=FALSE>>=
writeAS(as=asd, output.dir="example")
@

\subsection*{Details: PIR and PSI metrics}
\label{sec:psir}
To provide an integrative view of the AS events being analyzed, splice junction information is used to analyze differential bin usage. PSI (percent of inclusion) and PIR (percent of intron retention) metrics, which are extensively used to quantify AS \cite{pmid21057496}, are calculated for bins junctions (see figure
\ref{fig:pirEq} ). Both, the PIR and PSI metrics, strongly enrich the count-centric analysis and provide independent experimental support for the existence of novel AS events, based on the identification of corresponding changes in nearby splice junctions.
Only junctions that pass an abundance filter are considered for PSI/PIR calculation: a minimum number of counts (given by the threshold parameter) should be attained in all samples of at least one condition in order to consider the corresponding junction for further analysis (the default value of this threshold is five counts).

\begin{figure}[ht!]
    \centering
      \includegraphics[width=0.75\textwidth]{images/psi_pir2.pdf}
    \caption{PSI and PIR metrics estimation and their relationship with junctions}
\label{fig:pirEq}
\end{figure}

For each bin, a PIR or a PSI  metric is calculated, depending on the splicing event category assigned to that bin (see section \secref{sec:eventAssign}). If no splice event was assigned, meaning that the bin is not alternative, an exon will be considered to be involved in a putative exon skiping splicing event, and
an intron will be considered to be involved in a putative intron retention splicing event.

Every detected junction implies the existence of an intron that could be potentially retained. Therefore a PIR value is computed for every junction. Also, every junction defines a 5' and a 3' splicing site. Each one of these can be found exclusively in this junction or found also in other junctions. The latter is
evidence of an exon skipping event or an alternative 5' or 3' splicing site event. Althought is not possible to infer the kind of event, the computation of a PSI value is helpful to detect this cases. The details of the formulas used to calculte these values are shown in figure \ref{fig:psir_junc}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.75\textwidth]{images/psi_pir_junc.pdf}
  \caption{PSI and PIR metrics for junctions}
  \label{fig:psir_junc}
\end{figure}


\subsection{Differential signals: Differential gene expression and differential bin usage estimation}
Estimate differential expression at gene level and differential usage at bin level using diffSpliceDGE function from edgeR package.
\texttt{gbDUreport}: A Coverage-based differential signals analyisis of alternative splicing. \label{sec:du}

\texttt{ASpli} takes into account bins and junctions from expressed genes (see section \secref{sec:de}) if they have enough supporting reads (Default=5) in at least one 
condition. 
\begin{itemize}
\item {\em External bins} are excluded from the analysis. 
However, as an {\em external bin} for one isoform can overlap to a non external bin from other isoform that can participate in alternative splicing regulation, ASpli allows to optionally include them in the analysis. 
\item Io ({\em original intron}) bins can also be optionally excluded from the analysis.
\end{itemize}

Note that the inclusion of those bins can affect the estimation of corrected p-values (fdr). The information provided by intron original bins are highly correlated with the one of their sub bins and increase largely the number of events to be analyzed. Therefore the fdr correction is more strict. In this case there is a violation on the fdr correction assupmtion that all individual tests are independent from each other. If an Io bin shows a significant change, there is a very high chance that at least one of their sub bins also shows a significant change..

To run:
<<asd, echo=TRUE, eval=FALSE>>=
 gbDUreport( counts, 
             minGenReads = 10, 
             minBinReads = 5,
             minRds = 0.05, 
             contrast = NULL, 
             forceGLM = FALSE, 
             ignoreExternal = TRUE, 
             ignoreIo = TRUE, 
             ignoreI = FALSE,
             filterWithContrasted = TRUE,
             verbose = TRUE,
             formula = NULL,
             coef = NULL)
@

Exclusive parameters:
\begin{itemize}
\item minGenReads: Genes with at least an average of minGenReads reads for any condition are included into the differential expression test. Bins from genes with at least an average of minGenReads reads for all conditions are included into the differential bin usage test. (Default=10)
\item minBinReads: Bins with at least an average of minGenReads reads for any condition are included into the differential bin usage test. (Default=5)
\item minRds = genes with at least an average of minRds read density for any condition are included into the differential expression test. Bins from genes with at least an average of minRds read density for all conditions are included into the differential bin usage test. Bins with at least an average of minRds read density for any condition are included into the differential bin usage test. (Default=0.05)
\item ignoreExternal: Ignore Exon Bins at the beginning or end of the transcript. (Default = TRUE)
\item ignoreIo: Ignore original (full) introns. (Default = TRUE)
\item ignoreI: Ignore intronic bins, test is performed only for exons. (Default = FALSE) 
\item contrast: either a formula or a contrast can be tested. If contrast is used, it defines the comparison between conditions to be tested. It is a vector with length = number of experimental conditions (as defined by \texttt{targets}). 
The values of this vector are the coefficients that will be used to weight each condition. The order of the values corresponds to the order given by \texttt{getConditions()}. If contrast = NULL, the default is a vector -1, 1 and 0 for all the remaining conditions. This means a pairwise comparison where the first condition is assumed to be a control, the second condition is the treatment and all other conditions are ignored. (Default = NULL)
\item forceGLM: Force the use of a generalized linear model to estimate differential expression. It is not used to differential usage of bins. (Default = FALSE)
\item filterWithContrasted: a logical value specifying if bins, genes and junction will be filtered by read quantity and read density using data from those conditions that will be used in the comparison, i.e. those which coefficients in contrast argument are different from zero. The default value = TRUE. It is strongly recommended to do not change this value.
\item verbose: A logical value that indicates that detailed information about each step in the analysis will be presented to the user.
\item  formula: Either a formula or a contrast can be tested. If formula is used, complex tests can be run. It should be a formula specifying which experimental conditions defined by targets to test. If coef is specified, then that coefficient will be tested. If not, it defaults to the last term in the formula.
\item coef: for formula only. The coefficient to be tested. If null the test defaults to the last term in the formula
\end{itemize}

\subsubsection{jDUreport: A Junction-centered analysis of alternative splicing. Differential junction usage estimation}
Count data of bins and junctions can be used to get an integrative view of alternative splicing events. Estimate differential usage at junction level. It makes separate estimates for different types of junctions. Estimation is made at junction level using diffSpliceDGE function from edgeR package. The statistics works as follows. All junctions bellonging to the same event are put togheter and constitute the event \textit{gene}. Then, each junction is tested against this \textit{gene} in a similar fashion that bins are tested against their gene in diffSpliceDGE. Localec are clusters made of junctions that share an end with at least another junction in the cluster.

<<jDUreport, echo=TRUE, eval=FALSE>>=
jDUreport(asd, 
            minAvgCounts                       = 5, 
            contrast                           = NULL,
            filterWithContrasted               = TRUE,
            runUniformityTest                  = FALSE,
            mergedBams                         = NULL,
            maxPValForUniformityCheck          = 0.2,
            strongFilter                       = TRUE,
            maxConditionsForDispersionEstimate = 24,
            formula                            = NULL,
            coef                               = NULL,
            maxFDRForParticipation             = 0.05,
            useSubset                          = FALSE)
@

Where the exclusive parameters:
\begin{itemize}
\item asd: An object of class \texttt{ASpliAS} with results of PSI and PIR using experimental junction
\item minAvgCounts: Minimum average counts for filtering.
\item filterWithContrasted: A logical value specifying if bins, genes and junction will be filtered by read quantity and read density using data from those conditions that will be used in the comparison, i.e. those which coefficients in contrast argument are different from zero. Default=TRUE. It is strongly recommended to do not change this value.
\item runUniformityTest: Run uniformity test on \textbf{Intron Retention}. Sometimes Mutually Exclusive Exons (MEX) events can be confused with Intron Retention events. This test compares the standard deviation of the inner intron region (11 bases from both ends) to the mean of both intron ends. Numbers closer to 0 mean the event is more probably an Intron Retention event than an MEX event. The test takes some time to run so it defaults to FALSE.
\item mergedBams: Path to merged bams for each testing condition. \textit{ If no merged bams exist (for example, paired samples without replicates), use the same bams as targets.}
\item maxPValForUniformityCheck: To speed up uniformity test only check junctions with pval < maxPValForUniformityCheck (Default=0.2)
\item strongFilter: If strongFilter is TRUE, then we remove all events with at least one junction that doesn't pass the filter.
\item  maxConditionsForDispersionEstimate: In order to reduce resource usage, estimate dispersion for statistics tests with a reduced number of conditions.
\item maxFDRForParticipation: In order to calculate junctionPSI participation, only use significant junctions \textit{(ie junctions with FDR < maxFDRForParticipation).} (Default=0.05)
\item useSubset: Experimental. \textit{It is strongly recomended to leave the default, FALSE.}
\end{itemize}

Results are stored in an \texttt{ASpliJDU} object. Note that this analysis consider junctions that are completely included within a unique gene and have enough supporting reads (MinAvgCounts, Default = 5)
For each junction identified, it is reported:
\begin{itemize}
\item if it is novel ({\textit known CHEQUEAR}) 
\item which bins it spans
\item if the junction is completely included in an annotated bin, which would indicate that the AS event
is a possible \emph{exintron} \cite{pmid25934563}.
\end{itemize}
See {ref:ouputs} for more details.
\subsubsection*{Details: New splicing events discovery} 
\texttt{ASpli} allows novel AS events to be identified based on the splice junctions repertoire. A novel AS event is identified whenever a novel splice junction sharing its start or end with another splice junction is discovered. When a novel AS event is identified using the splice junction repertoire, the PSI metric is calculated and reported. 
\textbf{This ability to detect novel AS events and to estimate the magnitude of the changes in the usage
of these AS events under different experimental conditions are original functions of the package}

\subsection{Integrate signals: Splicing report} \label{sec:integration}

<<jDUreport, echo=TRUE, eval=FALSE>>=
sr      <- splicingReport(gb, 
                          jdur, 
                          counts)
@


This function integrates differential usage information from different sources. Receives bin usage and junction usage and merges them in three steps. First merges all bins with annotated junction information (jir, jes, jalt). Then finds all bins that overlap locale J3 junctions (the junctions that cover the entire locale region) and merges them. Finally it does the same with anchor.


<<jDUreport, echo=TRUE, eval=FALSE>>=
is      <- integrateSignals(sr,
                            asd)
@

Integrate signals:
\begin{itemize}
\item sr: An object of class ASpliSplicingReport
\item asd: An object of class ASpliDU
\item bin.FC: Filter bin signals by fold change. Actually, log2 fold change is return, so default would return only bin signlas with bin.fc > log2(3).
\item bin.fdr: Filter bin signals by fdr.
\item nonunif: Filter intronic bins with non uniform support (nonunif << 1 is uniform)
\item usenonunif: Use non uniformity as filter.
\item bin.inclussion: Filter bin signals by junction support with dPIR or dPSI accordingly.
\item bjs.inclussion: Filter annotated junction signals by junction inclussion with dPIR or dPSI accordingly.
\item bjs.fdr: Filter annotated junction signals by fdr.
\item a.inclussion: Filter anchor junction signals by junction inclussion with dPIR.
\item a.fdr: Filter anchor junction signals by fdr.
\item l.inclussion: Filter locale junction signals by junction inclussion with dPSI.
\item l.fdr: Filter locale junction signals by fdr.
otherSources. If user wants to compare ASpli results with results from other methods, otherSources must be a GenomicRange object with all the regions found with the other methods. It will be integrated with a new column next to signals information.
\item overlapType: Type of regions overlap matching between the different signals. Defaults to "any" and can be any of the following: "any", "start", "end", "within", "equal".
\end{itemize}

Description\\
Integrates differential usage signals from different sources using overlaping regions. Returns all overlaping signals present in the region filtered by different parameters. To construct this table, the region is marked with a 1 in the corresponding signal if the signal in that region was originated in that particular event. If other signals match the region, the other signals are also marked as 1. If other signals overlap but don't match, then those signals are marked with 

\subsection{Reports: exportSplicingReport()}
\label{sec:reports}
At each module, results are stored in \texttt{ASpliObjects}. Self-explanatory tables can be exported at each step of the analysis. Using \texttt{write} 
functions, it is possible to export tab delimited tables in a features-level output folder:

<<write, echo=TRUE, eval=FALSE>>=
writeCounts(counts, "example_counts")
writeDU(du, output.dir="example_du");
writeAS(as=as, output.dir="example_as");
writeAll(counts=counts, du=du, as=as, output.dir="example_all")
@

Column of text tables has the same name and meaning that those described in
\secref{sec:countsContents}, \secref{secASpliAsContent} and
\secref{sec:asplidu}. 
Exported text tables files are arranged in subfolders 
"exons", "genes", "introns" and "junctions". \texttt{writeAS} creates an 
additional text table:
\begin{description}
  \item[as\_discovery.tab] Contains junction counts and PSI/PIR metrics for all
    bins.
\end{description}

\texttt{writeAll} methods writes some additional tables:
\begin{description}
  \item[summary.tab] Contains bin DU usage for all bins together.
  \item[bins\_du\_psi\_pir.tab] Contains bin DU usage for all bins merged
  with PSI/PIR metrics.
\end{description}


Figure \ref{fig:plotGenomicRegion} shows a plot from one of the previuos
examples. 

\begin{figure}[ht!]
  \begin{center}
  \includegraphics[width=0.55\textwidth]{images/GENE02_E002_gr.pdf}
  \end{center}
  \caption{Genomic plot of a gene containing a exon skipping splicing event
  highlighted for four different conditions.}
  \label{fig:plotGenomicRegion}
\end{figure}

In addition to coverage plots, \texttt{ASpli} is able to draw plots containing
raw gene counts, raw bin counts, PSI/PIR value, inclusion and exclusion junction
counts for a single bin in all, or a subset, conditions of the analysis. This
plot is useful to integrate evidences of different sources in order to explain
an experimental result. The function to make these plots is \texttt{plotBins},
below there are some examples of use.

Example 1:
<<plotbins, echo=TRUE, eval=FALSE>>=
# Defines an experiment with one experimental factor (genotype, with two
# values: wild-type (WT) and mutant (MT) ), and three replicate samples for each
# condition.
targets <- data.frame(
  row.names = c( 'WT1', 'WT2', 'WT3', 
                 'MT1', 'MT2', 'MT3' ),
  bam = c( 'WT1.bam', 'WT2.bam', 'WT3.bam', 
           'MT1.bam', 'MT2.bam', 'MT3.bam' ),
  genotype = c( 'WT','WT','WT','MT','MT','MT' ),
  stringsAsFactors = FALSE )
# Specifies what factors and values will be plotted, in this example all of
# them.
fv = list( genotype = c( 'WT', 'MT' ) ) 
plotbins(
        counts, 
        as,
        'GENE02:E002', 
        factorsAndValues = fv, 
        targets )
@

Example 2:
<<plotbins, echo=TRUE, eval=FALSE>>=
# Defines an experiment with two experimental factor (treat, with four
# values: A, B, C and D; and time, with twelve values from T1 to T12.), and
# two replicate samples for each condition. In the definition, many values are
# not shown to reduce the space of the example, and are replaced by '...' . 
targets <- data.frame(
  row.names = c( 'A_T1.r1', 'A_T1.r2', 
                 'A_T2.r1', 'A_T2.r2',
                 ... , 
                 'D_T12.r1', 'D_T12.r2' ),
  bam = c( 'A_T1.r1.bam', 'A_T1.r2.bam', 
           'A_T2.r1.bam', 'A_T2.r2.bam',
           'D_T12.r1.bam', 'D_T12.r2.bam' ),
  treat = c( 'A', 'A',
             'A', 'A',
             ... ,
             'D', 'D' ),
  time = c( 'T1', 'T1',
            'T2', 'T2',
            ... ,
            'T12', 'T12' ),
  stringsAsFactors = FALSE )
# Draw the plots.
plotbins(
        counts, 
        as,
        'GENE02:E002', 
        factorsAndValues = fv, 
        targets )

# Specifies what factors and values will be plotted. In this example there are
# two factor, the first one in 'fv' list is the main factor, values will
# be grouped by this factor. 
fv = list( time = c( 'T1', 'T2', ... , 'T12' ) ,
           treat = c( 'A', 'B', 'C', 'D' ) ) 
# Draw the plots
plotbins(
        counts, 
        as,
        'GENE02:E002', 
        factorsAndValues = fv, 
        targets )
@


Figures \ref{fig:plotbinEx1} and \ref{fig:plotbinEx2} shows the images that can
be obtained in setups like shown in the examples above. Note that one image 
contains barplots, and the other contains lines. They are selected automatically
according to the number of conditions and values per condition. However, it is 
possible to force to one of them setting the argument \texttt{useBarPlots} in
\texttt{plotBins} method.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.6\textwidth]{images/GENE02_E002_pr.pdf}
  \caption{Plots of bin gene, and junction counts, and PSI/PIR metric for a
  single bin of an experiment containing a time course of 12 posints in four
  conditions. Gene expression seem to be constant across all conditions,
  however, the usage of the bin oscilates with time. Inclusion and
  exclusion junctions show a concordant behaviour.}
  \label{fig:plotbinEx1} 
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.25\textwidth]{images/GENE02_E002b_pr.pdf}
  \caption{Plots of bin gene, and junction counts, and PSI/PIR metric for a
  single bin of an experiment containing two combinatorial factors. Of those,
  only two conditions are shown. }
  \label{fig:plotbinEx2} 
\end{figure}


\subsection*{Useful functions}

ASpli includes many functions that help the use to manipulate the different ASpli objects.

\subsubsection{Access data in \texttt{ASpliDU} objects}

ASpliDU objects can contain data for gene, bins and/or junctions depending on
what function was used to create it. \texttt{DUreport} and
\texttt{DUreportBinSplice} methods returns \texttt{ASpliDU} objects with data
for gene and bins. \texttt{junctionDUreport} function returns an object with
junction data only or with gene, bins and junction depending on the input.
There are two function that are useful to know what kind of data an
\texttt{ASpliDU} contains: \texttt{containsJunctions} and
\texttt{containsGenesAndBins}. 

<<containsDUfunctions, echo=TRUE, eval=FALSE>>=
du <- aspliDUexample1()
containsJunctions( du )
containsGenesAndBins( du )
@

\subsubsection*{Filtering \texttt{ASpliCount} objects}

Genes, bins and junctions stored in an \texttt{ASpliCount} object can be
filtered by abundance according to several statments:
\begin{itemize}
  \item number of counts or read density.
  \item mean value or minimum value.
  \item grouping by condition or on the whole set.
  \item all conditions must pass the selection criteria or at least one condition must do it.
\end{itemize}

\texttt{filterReadCounts} method allow this filtering. Here there are some
examples:

%<<filterReadCounts, echo=TRUE, eval=FALSE>>=
%filterReadCounts(du)
%@


\subsubsection*{Filtering \texttt{ASpliDU} objects}
Results present in \texttt{ASpliDU} can be filtered by \textbf{logFC} and
\textbf{FDR} with \texttt{filterDU} function. Features with and \textbf{FDR}
value below to a given threshold (Default=1), and with an absolute \textbf{logFC}
greater than a given value (Default=0) are kept. \textit{SACAR (in other words, is not
filtered by that value).}

<<filterDU1, echo=TRUE, eval=FALSE>>=
# Filter genes that changes at least a 50 percent their expression with a 
# FDR value of 0.05 or less, and bins changes at least a 50 percent their expression with a 
# FDR value of 0.05 
du <- aspliDUexample1()
duFilt <- filterDU(du, 'genes', '0.05', log(1.5,2))
duFilt <- filterDU(duFilt, 'bins', '0.1', log(1.5,2))
@

It is possible to filter only those elements that has a positive
(or negative) \textbf{logFC} using the arguments \texttt{absLogFC} and
\texttt{logFCgreater}. \texttt{absLogFC} forces to take the absolute value of
\textbf{logFC}, this is \texttt{TRUE} by default. \texttt{logFCgreater}
specifies, if \texttt{TRUE}, that the \textbf{logFC} value must be greater than
the threshold.


<<filterDU2, echo=TRUE, eval=FALSE>>=
# Filter genes that reduces their expression to the half
du <- aspliDUexample1()
duFilt <- filterDU( du, 'genes', '0.05', -1, absLogFC = FALSE,
                    logFCgreater = FALSE  ) 
@

\subsubsection*{Subsetting \texttt{ASpli} objects}

\texttt{ASpliCounts}, \texttt{ASpliAS}, targets \texttt{data.frame} and list of
\texttt{GAlignments} (i.e. bam files data) can be subsetted by conditions or
samples.
<<subset, echo=TRUE, eval=FALSE >>=
# Subset counts
counts <- aspliCountsExample()
countsSmall <- subset(counts, targets, select = c("A_C", "A_D") )
# Subset AS results. Note that PIR/PSI metrics are not recalculated.
as <- aspliASexample()
asSmall <- subset(as, targets, select = c("A_C_0", "A_C_1") )
# Subset targets
targets      <- aspliTargetsExample()
targetsSmall <- subsetTargets( targets, c("A_C", "A_C") )
# Subset BAMs
bams     <- aspliBamsExample()
bamSmall <- subsetBams( bams, targets, c("A_C", "A_C") )
@

\subsubsection*{Merging DU and junction data for bins}

\texttt{mergeBinDUAS} function merges bin data from DU analysis contained in an
\texttt{ASpliDU} object and bin data from junction repertoire usage and PSI/PIR
metrics contained in an \texttt{ASpliAS} object. Also a delta PSI/PIR value is
calculated from a contrast vector.

<<mergeBinDUAS, echo=TRUE, eval=FALSE>>=
du <- aspliDUexample1()
as <- aspliASexample()
mergeBinDUAS(du,as, targets)
@

\section{Example data}
\subsection{Synthetic data set}
ASpli contains a small synthetic data set to test the complete working pipeline.
It consist of a genome with ten genes with multiple isoforms, a set of
\textbf{BAM} files from an experiment with two$\times$two factorial design, and
a \textbf{GTF} file with the corresponding annotation. The two factors in this
examples are called \textbf{f1} and \textbf{f2}. \textbf{f1} can have value
\textbf{A} or \textbf{B} and \textbf{f2} can have value \textbf{C} or
\textbf{D}, defining four conditions: \textbf{A.C}, \textbf{A.D}, \textbf{B.C}
and \textbf{B.D}. There are three replicates for each conditition (see table
\ref{tab:Ex01} ) .

\begin{table}[H]
  \begin{center}
    \begin{tabular}{lllll}
    Sample   & f1 & f2 & replicate & condition \\ \hline
    1        & A  & C  & 0         & A.C       \\
    2        & A  & C  & 1         & A.C       \\
    3        & A  & C  & 2         & A.C       \\
    4        & A  & D  & 0         & A.D       \\
    5        & A  & D  & 1         & A.D       \\
    6        & A  & D  & 2         & A.D       \\
    7        & B  & C  & 0         & B.C       \\
    8        & B  & C  & 1         & B.C       \\
    9        & B  & C  & 2         & B.C       \\
    10       & B  & D  & 0         & B.D       \\
    11       & B  & D  & 1         & B.D       \\
    12       & B  & D  & 2         & B.D       \\
    \end{tabular}
  \end{center}
  \caption{Experimental design of the example data set.}
  \label{tab:Ex01}
\end{table}

The firts step of the workflow is to build the TxDb object and extract their features.

<<Ex01.a, echo=TRUE, eval=FALSE>>=

library( GenomicFeatures )
# gtfFileName contains the full path to the example gtf file in your system.
gtfFileName <- aspliExampleGTF()

# Create a TxDb object using makeTxDbFromGFF function from GenomicFeatures 
# package
genomeTxDb <- makeTxDbFromGFF( gtfFileName )

# Extract the genomic features
features <- binGenome( genomeTxDb )

@

Then load the alignment and define your tragets:

<<Ex01.b, echo=TRUE, eval=FALSE>>=

# bamFiles contains the full path of the bam files in your system
bamFiles <- aspliExampleBamList( )

# Define the targets
targets <- data.frame( 
  row.names = paste0('Sample',c(1:12)),
  bam = bamFiles,
  f1 = c( 'A','A','A','A','A','A',
          'B','B','B','B','B','B'),
  f2 = c( 'C','C','C','D','D','D',
          'C','C','C','D','D','D'),
  stringsAsFactors = FALSE
)

# Examinate the condition names
getConditions(targets)

# Load the bam files
bams = loadBAM(targets)
@

Next step is to overlap the reads and the features:

<<Ex01.c, echo=TRUE, eval=FALSE>>=
counts <- readCounts( features, bams, targets, readLength = 100, 
                      maxISize = 5000 )
@

Now you can run the DE/DU analysis. We will test the hypothesis
that the expression of some genes respond to the interaction of \textbf{f1} and
\textbf{f2}. In other words, that the observed effect of applying the two
factors can not be explained by the independent contribution of each factor.
The interaction can be expressed as:
\begin{equation}
I = ( B.D - B.C ) - ( A.D - A.C ) 
\end{equation}
The coefficients of the terms in this expression can be represented in the
contrast vector $[1,-1,-1,1]$, assuming that they correspond to the order given
by \texttt{getConditions} function.

<<Ex01.d, echo=TRUE, eval=FALSE>>=
# DU/DE analysis for genes and bins.
du <- DUreport( counts, targets, contrast = c( 1, -1, -1, 1 ) )
# DU analysis for junctions
du <- junctionDUReport( counts, targets, appendTo = du, 
                        contrast = c( 1, -1, -1, 1 ) )
@

The discovery of AS events can be done with:
<<Ex01.e, echo=TRUE, eval=FALSE>>=
# AS analysis 
as <- AsDiscover( counts, targets, features, bams, readLength = 100)
@

Finally, you can select your top tags integrating differential usage data and
junction data.

<<Ex01.f, echo=TRUE, eval=FALSE>>=
# Select top tags from DU
topTagsBins <- filterDU( du, what = 'bins', fdr = 0.05, logFC = log(1.5,2) )
# DU results are merged with AS results
topTagsBins <- mergeBinDUAS( du, as, targets, contrast = c( 1, -1, -1, 1 ) )
# We filter those top tags that have also junction evidence that supports the
# differential usage, a change of at least 0.1 between observed and expected 
# in the PSI or PIR metric is required.
topTagsBins <- topTagsBins[ abs(topTagsBins[,'delta' ]) > 0.10,]
@

Bin \textbf{GENE10:E002} is the one with the lowest \textbf{FDR} value, now we
can examine it in a plot. The results in figure \ref{fig:Ex01gr} show that a
change in \textbf{f1} from \textbf{A} to \textbf{B} has not the same outcome for
\textbf{C} or \textbf{D} in \textbf{f2}. 

<<Ex01.f, echo=TRUE, eval=FALSE>>=
plotGenomicRegions( features,'GENE10:E002', genomeTxDb, targets )
@

\begin{figure}[!ht]
  \centering
  \includegraphics[width=0.55\textwidth]{images/GENE10_E002_gr.pdf}
  \caption{Genomic region of example bin \textbf{GENE10:E002}.}
  \label{fig:Ex01gr}
\end{figure}

\subsection{Real data set}

It is possible to run a demo of \texttt{ASpli} using public \RNAseq data 
available via Bioconductor. The package 
\texttt{RNAseqData.HNRNPC.bam.chr14} contains reads aligned to Chromosome 14 which come from an 
experiment intended to analyze the effect of the HNRNPC splicing factor knock down.

exonization of Alu elements and alternative splicing \cite{Zarnack2013453}
Transcription profiling by high throughput sequencing of HNRNPC knockdown and control HeLa cells. They performed RNA-seq experiments on two replicate samples from each HNRNPC knockdown (KD1 and KD2). \\
We load the package and the annotation:
%<<librariesEx, echo=TRUE, eval=TRUE>>=
<<Ex02.a, echo=TRUE, eval=FALSE>>=
library(RNAseqData.HNRNPC.bam.chr14)
@

In this case we are loading a genome \texttt{TranscriptDb} already created and 
available in the \texttt{ASpli} package for the \textit{Homo sapiens}
chromosome 14:

<<Ex02.b, echo=TRUE, eval=FALSE>>=
chr14 <- system.file("extdata","chr14.sqlite", package="ASpli")
genome <- loadDb(chr14)
@


And now we are ready to start the whole analysis.
%<<binGenome, echo=TRUE, eval=TRUE>>=
<<Ex02.c, echo=TRUE, eval=FALSE>>=
features <- binGenome(genome) 
@

This data set contains data for two conditions \textbf{KD} and \textbf{CT}
with four replicates each one. 
Create targets object using the information of the available files:
%<<targetsEx, echo=TRUE, eval=TRUE>>=
<<Ex02.d, echo=TRUE, eval=FALSE>>=
targets <- data.frame( 
              bam = RNAseqData.HNRNPC.bam.chr14_BAMFILES,
              treat = c( "CT", "CT", "CT", "CT", 
                         "KD", "KD", "KD", "KD" ),
              stringsAsFactors = FALSE )
@
Then, overlap alignments with the features:
%<<todosJuntos, eval=TRUE>>=
<<Ex02.f, eval=FALSE>>=
counts      <-  gbCounts(features = features, bam = bams, targets =
                           targets, minReadLength = 75, maxISize = 5000)
@

\subsection{Details Ouputs}
\label{sec:outputs}
ASpliCounts:
\begin{itemize}
  \item Gene counts (\texttt{countsg}) and gene read densities (\texttt{rdsg})
  \texttt{data.frames} contain the following information (see table 
  \ref{tab:counts.gene} for an example):
    \begin{description}
      \item[row.names] Gene name as reported in annotation data.
      \item[symbol] An optional common name for the gene, that must be provided at
      the moment of feature extraction (see section
      \secref{sec:binDefinition}).
      \item[locus\_overlap] Names of overlapping \textit{loci}.
      \item[gene\_coordinates] Genomic coordinates of the gene with
      format \texttt{chromosome:start-end}.
      \item[start] Left-most position of the gene.
      \item[end] Right-most position of the gene.
      \item[length] Number of bases covering the gene.
      \item[effective\_length] Number of bases that overlaps with annotated exons.
      \item[sample data] Gene counts or read density (one column per sample).
      \\
    \end{description} 

  \item Bin counts (\texttt{countsb}) and bin read densities (\texttt{rdsb}) \texttt{data.frames} contain the
  following information:
    \begin{description}
      \item[row.names] Bin name assigned according to the convention presented in \secref{sectionBinG}.
      \item[feature] Type of bin: \textbf{E} for exonic bins, \textbf{I}
      for intronic bins and \textbf{Io} for introns before splitting.
      \item[event] Splicing event asigned to the bin (see section
      \ref{sec:binDefinition}:\nameref{sec:eventAssign})
      \item[locus] The name of the locus that contains the bin.
      \item[locus\_overlap] Names of all other overlapping \textit{loci}.
      \item[symbol] An optional common name for the gene, that must be provided at
      the moment of feature extraction (see section \secref{sec:binDefinition}).
      \item[gene\_coordinates] Genomic coordinates of the gene with
      format \texttt{chromosome:start-end}.
      \item[start] Left-most position of the bin.
      \item[end] Right-most position of the bin.
      \item[length] Number of bases covering the bin.
      \item[sample data] Bin counts or read density (one column per sample)
      densities.
      \\
    \end{description}

  \item Junction counts (\texttt{countsj}) \texttt{data.frame} contains the following information:
    \begin{description}
      \item row.names: Junction name in format
      \texttt{chromosome.start.end} (see \secref{sectionBinG}).
      \item junction: If junction coincides with a junction inferred
      from the annotation, the name is shown as is given in section
      \ref{sectionBinG}:\nameref{sectionBinG}, otherwise it contains \texttt{noHit}.
      \item gene: Locus that contains the junction.
      \item strand: sense strand of the gene.
      \item multipleHit: \texttt{yes} if junction spans multiple genes.
      \item symbol: An optional common name for the gene, that must be provided at
      the moment of feature extraction (see section
      \secref{sec:binDefinition}).
      \item gene\_coordinates: Genomic coordinates of the gene with
      format \texttt{chromosome:start-end}.
      \item bin\_spanned: Names of the bins spanned by the junction.
      \item j\_within\_bin: If junction falls within a single bin, the name of
      that bin is shown.
      \item sample data: Junction counts (one column per sample).
      \\
    \end{description}

  \item E1I (\texttt{e1icounts}) and IE2 (\texttt{ie2counts}) flanking region count \texttt{data.frame} contain the
  following information:
    \begin{description}
      \item row.names: Junction name in format \texttt{chromosome.start.end}
      (see \secref{sectionBinG}).
      \item junction: If junction coincides with a junction inferred
      from the annotation, the name is shown as is given in section
      \ref{sec:binDefinition}:\nameref{sec:binDefinition}, otherwise
      contains \texttt{noHit}.
      \item gene: Name of the locus that contains the junction.
      \item strand: Strand sense of the gene.
      \item multipleHit: \texttt{yes} if junction spans multiple
      genes.
      \item symbol: An optional common name for the gene, that must be provided at
      the moment of feature extraction (see section \ref{sec:binDefinition}:\nameref{sec:binDefinition}).
\item gene\_coordinates: Show the genomic coordinates of the gene with format \texttt{chromosome:start-end}.
      \item bin\_spanned: Names of the bins spanned by the junction.
      \item j\_within\_bin: If junction falls within a single bin, the name of that bin is shown.
\item sample data: Junction counts (one column per sample).
\end{description}
    
\end{itemize}

\begin{table}
\centering
\begin{tabular}{lllllllllll}
\rotatebox{90}{Row names} & 
\rotatebox{90}{symbol} &
\rotatebox{90}{locus\_overlap} &
\rotatebox{90}{gene\_coordinates} &
\rotatebox{90}{start} &
\rotatebox{90}{end} &
\rotatebox{90}{length} &
\rotatebox{90}{effective\_length} &
\rotatebox{90}{Sample 1} & 
\rotatebox{90}{Sample 2} &
\rotatebox{90}{ ... } \\ \hline
GENE01 & GENE01 & - & chr1:1-700     & 1    &  700 & 700 & 700 & 324 & 314 & n\\
GENE02 & GENE02 & - & chr1:1001-1800 & 1001 & 1800 & 800 & 550 & 327 & 333 & n\\
GENE03 & GENE03 & - & chr1:2001-2800 & 2001 & 2800 & 800 & 650 & 342 & 321 & n\\  
GENE04 & GENE04 & - & chr1:3001-3800 & 3001 & 3800 & 800 & 650 & 313 & 337 & n\\  
...    & ...    &...& ...            & ...  & ...  & ... & ... & ... & ... &
...
\end{tabular}
\caption{Gene counts table example.}
\label{tab:counts.gene}
\end{table}

ASpliAS:
\begin{itemize}
\item irPIR
\begin{itemize}
\item event: Type of event asigned by ASpli when bining. 
\item J1: Semicolon separated list of all the junctions with an end matching the start of the intron. J2: Semicolon separated list of all the junctions with an end matching the end of the intron. J3: Semicolon separated list of all the junctions overlaping the intron. All the columns from J1 to J2 represent the J1 counts in the different samples for each bin. The counts are the sum of all the J1 junctions. All the columns from J2 to J3 represent the J2 counts in the different samples for each bin. The counts are the sum of all the J2 junctions. All the columns from J3 to the first condition represent the J3 counts in the different samples for each bin. The counts are the sum of all the J3 junctions. The last columns are the PIR metrics calculated for each condition. The PIR metric is calculated as: PIR = (J1 + J2)/(J1 + J2 + 2*J3)
Where the junctions are the sum by condition.
\end{itemize}

\item altPSI
\begin{itemize}
\item event: Type of event asigned by ASpli when bining. 
\item J1(J2): Semicolon separated list of all the junctions with an end matching the end of alt5'SS(alt3'SS). 
\item J3: Semicolon separated list of all the junctions with an end matching the start of alt5'SS or the start of alt3'SS. All the columns from J1 to J2 represent the J1 counts in the different samples for each bin. The counts are the sum of all the J1 junctions. All the columns from J2 to J3 represent the J2 counts in the different samples for each bin. The counts are the sum of all the J2 junctions. All the columns from J3 to the first condition represent the J3 counts in the different samples for each bin. The counts are the sum of all the J3 junctions. 
\item The last columns are the PSI metrics calculated for each condition. The PSI metric is calculated as: PSI = (J12)/(J12 + J3). Where J12 is J1 if it's an alt 5' event or J2 if it's an alt 3' event and the junctions are the sum by condition.
\end{itemize}

\item esPSI	
\begin{itemize}
\item event: Type of event asigned by ASpli when bining 
\item J1: Semicolon separated list of all the junctions with an end on the alternative exon. 
\item J2: Semicolon separated list of all the junctions with an end on the alternative exon. 
\item J3: Semicolon separated list of all the junctions overlaping the alternative exon. All the columns from J1 to J2 represent the J1 counts in the different samples for each bin. The counts are the sum of all the J1 junctions. All the columns from J2 to J3 represent the J2 counts in the different samples for each bin. The counts are the sum of all the J2 junctions. All the columns from J3 to the first condition represent the J3 counts in the different samples for each bin. The counts are the sum of all the J3 junctions. 
\item The PSI metric is calculated as: PSI = (J1 + J2)/(J1 + J2 + 2*J3) Where the junctions are the sum by condition.
\end{itemize}

\item junctionsPIR
\begin{itemize}
\item PIR metric for each experimental junction using e1i and ie2 counts. Exclusion junction is the junction itself. This output helps to discover new introns as well as new retention events. 
\item hitIntron: If the junction matches a bin, the bin is shown here. 
\item hitIntronEvent: If the junction matches a bin, the type of event asigned by ASpli to this bin. All the columns from hitIntronEvent up to the first repetition of the samples names in the columns, represent the J1 counts in the different samples for each region. From there to the next time the names of the columns repeat themselves, the J2 counts and from there to the first condition, the J3 counts. 
\item The last columns are the PIR metrics calculated for each condition. The PIR metric is calculated as: PIR = (J1 + J2)/(J1 + J2 + 2*J3) Where the junctions are the sum by condition.
\end{itemize}

\item junctionsPJU
\begin{itemize}

\item Given a junction, it is possible to analyze if it shares start, end or both with another junction. If so, it is because there is alternative splicing. 
\item Junction: name of the junction. 
\item Gene: gene it belongs to. 
\item Strand: gene strand. 
\item multipleHit: if other gene overlaps the gene the junction belongs to. 
\item symbol: gene symbol. 
\item gene\_coordinates: gene coordinates. 
\item bin\_spanned: semicolon separated list of all the bins spaned by this junction. 
\item j\_within\_bin: other junctions in the bins. 

\item StartHit: all the junctions sharing the start with this junction and $PJU_J1=J3/(J1+J3)$ for each condition. 

\item EndHit: all the junctions sharing the end with this junction and $PJU_J2=J3/(J2+J3)$ for each condition. 

\item All the columns between j\_within\_bin and StartHit are the counts for J3 in the different samples for each region. From there to EndHit, the J1 counts and $PJU_J1=J3/(J1+J3)$ for each condition. Then after EndHit, the J2 counts and $PJU_J2=J3/(J2+J3)$. 
\item Rownames are J3 range. 
\item StartHit is J1 range and EndHit is J2 range.


\end{itemize}


ultimo dia deadline

\end{itemize}


\bibliography{ASpli}
\end{document}


